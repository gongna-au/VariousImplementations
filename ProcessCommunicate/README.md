## 进程间的通讯方式

**每个进程拥有独立的地址空间，但是可以共享内核空间，所以进程间的通讯必须要经过内存。**
每个进程的⽤户地址空间都是独⽴的，⼀般⽽⾔是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。Linux 内核提供了不少进程间通信的机制，我们来⼀起瞧瞧有哪些？

### 1.管道

管道类型————匿名管道
`ps auxf | grep mysql`

上⾯命令⾏⾥的「 | 」竖线就是⼀个管道，它的功能是将前⼀个命令（ psauxf ）的输出，作为后⼀个命令（ grep mysql ）的输⼊，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才⾏。同时，我们得知上⾯这种管道是没有名字，所以「 | 」表示的管道称为匿名管道，⽤完了就销毁。

**管道是单向输出的。**

管道类型————命名管道
FIFO ，因为数据是先进先出的传输⽅式

```shell
mkfifo myPipe
```

myPipe 就是这个管道的名称，基于 Linux ⼀切皆⽂件的理念，所以管道也是以⽂件的⽅式存在，我们可以⽤ ls 看⼀下，这个⽂件的类型是 p，也就是 pipe（管道） 的意思：

```shell
prw-rw-r--  1 gongna gongna        0 11月  5 11:17 mypipe
```

接下来，我们往 myPipe 这个管道写⼊数据

```shell
echo "hello" > mypipe
```

你操作了后，你会发现命令执⾏后就停在这了，这是因为管道⾥的内容没有被读取，只有当管道⾥的数据被读完后，命令才可以正常退出。

```shell
cat < mypipe
```

管道这种通信⽅式效率低，不适合进程间频繁地交换数据。当然，它的好
处，⾃然就是简单，同时也我们很容易得知管道⾥的数据已经被另⼀个进程读取了
匿名管道的创建，需要通过下⾯这个系统调⽤：

```c
int pipe(int fd[2])
```

这⾥表示创建⼀个匿名管道，并返回了两个描述符，⼀个是管道的读取端描述符 fd[0] ，另⼀个是管道的写⼊端描述符 fd[1] 。注意，这个匿名管道是特殊的⽂件，只存在于内存，不存于⽂件系统中。其实，所谓的管道，就是内核⾥⾯的⼀串缓存。从管道的⼀段写⼊的数据，实际上是缓存在内核中的，另⼀端读取，也就是从内核中读取这段数据。另外，管道传输的数据是⽆格式的流且⼤⼩受限。
看到这，你可能会有疑问了，这两个描述符都是在⼀个进程⾥⾯，并没有起到进程间通信的作⽤，怎么样才能使得管道是跨过两个进程的呢？
我们可以使⽤ fork 创建⼦进程，创建的⼦进程会复制⽗进程的⽂件描述符，这样就做到了两个进程各有两个「 fd[0] 与 fd[1] 」，两个进程就可以通过各⾃的 fd 写⼊和读取同⼀个管道⽂件实现跨进程通信了。
管道只能⼀端写⼊，另⼀端读出，所以上⾯这种模式容易造成混乱，因为⽗进程和⼦进程都可以同时写⼊，也都可以读出。那么，为了避免这种情况，通常的做法是：

- ⽗进程关闭读取的 fd[0]，只保留写⼊的 fd[1]；
- ⼦进程关闭写⼊的 fd[1]，只保留读取的 fd[0]；

所以说如果需要双向通信，则应该创建两个管道
所以说，在 shell ⾥通过「 | 」匿名管道将多个命令连接在⼀起，实际上也就是创建了多个⼦进程，那么在我们编写 shell 脚本时，能使⽤⼀个管道搞定的事情，就不要多⽤⼀个管道，这样可以减少创建⼦进程的系统开销。
我们可以得知，**对于匿名管道，它的通信范围是存在⽗⼦关系的进程**。因为管道没有实体，也就是没有管道⽂件，只能通过 fork 来复制⽗进程 fd ⽂件描述符，来达到通信的⽬的。
另外，对于**命名管道，它可以在不相关的进程间也能相互通信**。因为命令管道，提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信。**不管是匿名管道还是命名管道，进程写⼊的数据都是缓存在内核中，另⼀个进程读取数据时候⾃然也是从内核中获取，同时通信数据都遵循先进先出原则，不⽀持 lseek 之类的⽂件定位操作。**

### 2.消息队列

**由存储在内核中的消息队列作为两个进程通信的中介**

**消息队列是保存在内核中的消息链表。**发送数据的时候会分成一个一个独立的数据单元，也就是消息体，消息体是用户自定义的数据类型，消息的发送⽅和接收⽅要
约定好消息体的数据类型，所以每个消息体都是固定⼤⼩的存储块，**管道存储的是无格式的字节流数据。**如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽前⾯提到的匿名管道的⽣命周期，是随进程的创建⽽建⽴，随进程的结束⽽销毁。
**消息队列随内核的创建而创建，随着内核的结束而结束。匿名管道随着进程的创建而创建随着进程的结束而结束。**消息这种模型，两个进程之间的通信就像平时发邮件⼀样，你来⼀封，我回⼀封，可以频繁沟通了。

管道的通信⽅式是效率低的，因此管道不适合进程间频繁地交换数据。对于这个问题，消息队列的通信模式就可以解决。⽐如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。

##### 消息队列的缺点

1. 通信不及时
2. 消息的大小有限制(每个消息体有大小限制，且消息队列也有最大长度的限制)
   消息队列不适合⽐较⼤数据的传输，因为在内核中每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所包含的全部消息体的总⻓度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB ，它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最
   ⼤⻓度
3. 消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销。因为当进程**写入数据到内核中的消息队列的时候，会发生从用户态拷贝数据到内核态**的过程，另一个进程读取数据的时候会发生从内核态拷贝数据到用户态。

### 3.共享内存

**解决了用户态到内核态之间数据拷贝的过程**
现代操作系统，对于内存管理，采⽤的是虚拟内存技术，也就是每个进程都有⾃⼰独⽴的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是⼀样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。
**内存共享的本质是：拿出一块虚拟地址空间，映射到相同的物理内存。这个进程往那个物理地址写数据，另外一个进程立马就能看到了。都不需要拷贝**

### 4.信号量

**解决了共享同一块物理地址带来的，写入数据被覆盖，多个进程同时操作地址空间带来的数据错乱。**
**信号量实现了一种对于进程通信--共享内存的保护机制。**
**信号量用来实现进程间的互斥和同步，而不是用来缓存进程间通讯的数据**
信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。

⽤了共享内存通信⽅式，带来新的问题，那就是如果多个进程同时修改同⼀个共享内存，很有可能就冲突了。例如两个进程都同时写⼀个地址，那先写的那个进程会发现内容被别⼈覆盖了。

- ⼀个是 P 操作（尝试获取资源操作），这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。
- 另⼀个是 V 操作（尝试释放资源操作），这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有
  阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞
  中的进程。

**P 操作相当于一个所有进程都能看到的变量，每个进程都先尝试对这个-1，如果减 1 后仍然 >0 ，表示下一个拿到这个变量的进程不会被阻塞？如果<=0,那么意味着下一个进程就会被阻塞。**

**V 操作相当于一个所有进程都能看到的变量，每个进程都先尝试对这个+1，如果+1 后仍然 <=0 ，表示下一个拿到这个变量的进程会被阻塞？如果>0,那么意味着下一个进程就不会被阻塞。**

#### 进程互斥过程

举个例⼦，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1。

- 进程 A 在访问共享内存前，先执⾏了 P 操作，由于信号量的初始值为 1，故在进程 A 执⾏ P 操作后信号量变为 0，表示共享资源可⽤，于是进程 A 就可以访问共享内存。
- 若此时，进程 B 也想访问共享内存，执⾏了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占⽤，因此进程 B 被阻塞。
- 直到进程 A 访问完共享内存，才会执⾏ V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执⾏ V 操作，使信号量恢复到初始值 1。

可以发现，信号初始化为 1 ，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。

#### 进程同步过程

例如，进程 A 是负责⽣产数据，⽽进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先⽣产了数据，进程 B 才能读取到数据，所以执⾏是有前后顺序的。如果要来实现多进程同步的⽅式，我们可以初始化信号量为 0 。
具体过程： -如果进程 B ⽐进程 A 先执⾏了，那么执⾏到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没⽣产数据，于是进程 B 就阻塞等待；
接着，当进程 A ⽣产完数据后，执⾏了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；最后，进程 B 被唤醒后，意味着进程 A 已经⽣产了数据，于是进程 B 就可以正常读取数据了

### 5.信号

在 Linux 操作系统中， 为了响应各种各样的事件，提供了⼏⼗种信号，分别代表不同的意义。我们可以通过 kill -l 命令，查看所有的信号：

```shell
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
```

- Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程；
- Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束
- 如果进程在后台运⾏，可以通过 kill 命令的⽅式给进程发送信号，但前提需要知道运⾏中
  的进程 PID 号，例如：kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，⽤来⽴即结束该进程；

#### 信号的来源（1.硬件来源）（2.软件来源）

信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）
**信号是进程通讯间唯一的异步通讯机制**，所谓异步，就是在任何时刻可以发送信号给某个进程，一旦接收到某个信号，那么对于信号的处理有下面几个方式：

- 执行默认操作。Linux 对每种信号都规定了默认操作，例如，上⾯列表中的 SIGTERM 信号，就是终⽌进程的意思。
- 捕捉信号。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。
- 忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个
  信号是应⽤进程⽆法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，它们⽤于在任何时候中断或
  结束某⼀进程。

### 6.Socket

##### socket 的系统调⽤：

```c
// type SOCK_STREAM SOCK_DGRAM SOCK_RAW
int socket(int domain, int type, int protocal)
```

- domain :指定协议族。⽐如 AF_INET ⽤于 IPV4、AF_INET6 ⽤于 IPV6、AF_LOCAL/AF_UNIX ⽤于本机；
- type 参数⽤来指定通信特性，⽐如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；
- protocal 参数原本是⽤来指定通信协议的，但现在基本废弃。因为协议已经通过前⾯两个参数指定完成，protocol ⽬前⼀般写成 0 即可；

根据创建 socket 类型的不同，通信的⽅式也就不同：
实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；
实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；
实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；

##### 三种通信的编程模式

###### 1.针对 TCP 协议通信的 socket 编程模型

- 服务端和客户端初始化`Socket` 得到文件描述符
- 服务端调用`Bind` 绑定 IP 地址和端口（谁的 IP 地址和端口）
- 服务端口调用`Listen` 进行监听
- 服务端口调用`Accept` 等待连接

- 客户端调用`Connect` 向服务器的地址和端口发起连接请求
- **服务端`Accept`，返回用户传输的`Socket`的文件描述符**
- 客户端调用`Write` 写入数据，服务端调用`Read`读取数据
- 客户端断开连接，调用`Close` ,服务端读取数据的时候，就会遇到读取 EOF ，等待处理完数据就会调用`Close` 表示连接关闭。

服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket，
后续⽤来传输数据。监听的 socket 和真正⽤来传送数据的 socket，是「两个」 socket，⼀个叫作**监听 socket**，⼀个叫作**已完成连接 socket**。成功连接建⽴之后，双⽅开始通过 read 和 write 函数来读写数据，就像往⼀个⽂件流⾥⾯写
东⻄⼀样。

**已完成连接 socket**被客户端和服务端共享

###### 2.UDP 协议通信的 socket 编程模型

UDP 是没有连接的，所以不需要三次握⼿，也就不需要像 TCP 调⽤ listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端⼝号，因此也需要 bind。

- 服务端和客户端初始化`Socket` 得到文件描述符
- 服务端调用`Bind` 绑定 IP 地址和端口（谁的 IP 地址和端口）
- 服务端调用`receform` 传入目标地址的 IP 地址和端口
- 客户端调用`sendto` 发送 IP 地址和端口

```go
func Client(){
    socket:=NewClientSocket()
    socket.Bind()
    socket.sendto()
    socket.recvform()
}

func Server(){
    socket:=NewClientSocket()
    socket.Bind()
    socket.recvform()
    socket.sendto()
}

```

本地 socket 被⽤于在同⼀台主机上进程间通信的场景：

- 本地 socket 的编程接⼝和 IPv4 、IPv6 套接字编程接⼝是⼀致的，可以⽀持「字节流」和「数据报」两种协议；
- 本地 socket 的实现效率⼤⼤⾼于 IPv4 和 IPv6 的字节流、数据报 socket 实现；

- 对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。
- 对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端⼝，⽽是绑定⼀个本地⽂件，这也就是它们之间的最⼤区别。

### 总结

由于每个进程的⽤户空间都是独⽴的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享⼀个内核空间。
Linux 内核提供了不少进程间通信的⽅式，其中最简单的⽅式就是管道，管道分为「匿名管道」和「命名管道」。
匿名管道是特殊文件，只存在于进程（内存）。匿名管道的⽣命周期随着进程创建⽽
建⽴，随着进程终⽌⽽消失。因为使 shell 命令中的「 | 」竖线就是匿名管道，命名管道存在于内核。管道的通讯方式是单向的，数据只能在一个方向上流动，且匿名管道是存在于**父子关系的进程通信**

命名管道的本质是：**在操作系统中创建一个类型为 p 的设备文件，那么毫⽆关系的进程就可以通过这个设备⽂件进⾏通信。另外，不管是匿名管道还是命名管道，进程写⼊的数据都是缓存在内核中，另⼀个进程读取数据时候⾃然也是从内核中获取，同时通信数据都遵循先进先出原则，不⽀持 lseek 之类的⽂件定位操作。**

但是管道之间不能频繁的发送数据，因此可以通过消息队列来发送数据和接收数据。

消息队列的本质是： **保存在内核的「消息链表」**
消息队列克服了管道通信的数据是⽆格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以⽤户⾃定义的数据类型，发送数据时，会被分成⼀个⼀个独⽴的消息体，当然接收数据时，也要与发送⽅发送的消息体的数据类型保持⼀致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写⼊和读取都需要经过⽤户态与内核态之间的拷⻉过程。

消息队列随着内核的创建而创建，随着内核的消失而消失，消息队列处于内核。
但是消息队列涉及到用户态和内核态之间数据切换的问题，所以通过共享内存（虚拟地址映射到同一块物理地址）来解决。

共享内存的本质是： **相同的物理地址**
可以解决消息队列通信中⽤户态与内核态之间数据拷⻉过程带来的开销，它直接分
配⼀个共享空间，每个进程都可以直接访问，就像访问进程⾃⼰的空间⼀样快捷⽅便，不需要陷⼊内核态或者系统调⽤，⼤⼤提⾼了通信的速度，享有最快的进程间信⽅式之名。但是便捷⾼效的共享内存通信，带来新的问题，多进程竞争同个共享资会造成数据的错乱。

信号量的本质是： **互斥访问，进程同步**
共享内存存在不同的进程同时操作带来的数据混乱问题，所以信号量为进程的通信提供了保护机制。

信号的本质是： **进程间通信机制中唯⼀的异步通信机制**
信号是进程唯一的异步通讯的机制，软件信号有 kill 硬件信号有 Ctrl +C ,Socket ，其实现的本质是：**信号可以在应用进程和内核之间进行交互，内核可以利用信号，通知用户空间的进程发生了什么，⼀旦有信号发⽣，进程有三种⽅式响应信号 1. 执⾏默认操作、2. 捕捉信号、3. 忽略信号。**

以上的通信机制，都是⼯作于同⼀台主机
Socket 通讯的本质是： **不同主机之间的进程通讯，以及本地主机进程间通讯**

那线程通信间的⽅式呢？
**线程间我们关注的不是他们的通讯方式，而是他们是如何竞争进程资源的**
同一个进程下的线程共享该线程的资源，对于进程内的共享变量，线程之间都可以通信。⽐如全局变量，所以对于线程间关注的不是通信⽅式，⽽是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步。
