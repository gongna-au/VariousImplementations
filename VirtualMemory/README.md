## 虚拟内存管理

### 一条 Load 指令的执行过程:

1. 在 CPU ⾥访问⼀条 Load M 指令，然后 CPU 会去找 M 所对应的⻚表项。
2. 如果该⻚表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「⽆效的」，则 CPU 则会发送缺⻚中断请求。
3. 操作系统收到了缺⻚中断，则会执⾏缺⻚中断处理函数，先会查找该⻚⾯在磁盘中的⻚⾯的位置。
4. 找到磁盘中对应的⻚⾯后，需要把该⻚⾯换⼊到物理内存中，但是在换⼊前，需要在物理内存中找空闲⻚，如果找到空闲⻚，就把⻚⾯换⼊到物理内存中。
5. ⻚⾯从磁盘换⼊到物理内存完成后，则把⻚表项中的状态位修改为「有效的」。
6. 最后，CPU 重新执⾏导致缺⻚异常的指令。
   ⻚表项通常有如下图的字段：
   页号 物理页号 状态位 访问字段 修改位 硬盘地址

- 状态位：⽤于表示该⻚是否有效，也就是说是否在物理内存中，供程序访问时参考
- ⽤于记录该⻚在⼀段时间被访问的次数，供⻚⾯置换算法选择出⻚⾯时参考
- 修改位：表示该⻚在调⼊内存后是否有被修改过，由于内存中的每⼀⻚都在磁盘上保留⼀份副本，因此，如果没有修改，在置换该⻚时就不需要将该⻚写回到磁盘上以减少系统的开销；如果已经被修改，则将该⻚重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。

- 硬盘地址：⽤于指出该⻚在硬盘上的地址，通常是物理块号，供调⼊该⻚时使⽤。
  总结一下： 需要记录的信息有：1.是否在内存、（如果不在内存）2.在硬盘中间的地址、3.该资源被加载在内存之后是否被修改（如果被修改则需要记录并在操作结束之后返回把修改后的数据写入到硬盘）、4，该资源被调入内存多少次数（用来记录资源的使用率，便于当内存满了的时候，从中不经常使用的资源，并把该资源所占用的内存的位置腾出来）

  ```go
  type Table struct{
    // 是否在内存
    IsInMemory bool
    // 在硬盘中的地址
    LocationInHardDisk int
    // 被调入内存使用的次数
    UsedNum int
    // 被调入内存是否被修改
    IsChanged bool
  }

  // 模拟程序要访问100这个页面 load 100
  var page =100
  // 模拟保存页面的页表
  var table []int

  if page > len(tabel){
    fmt.P
  }


  ```
